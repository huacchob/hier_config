# Experimental Features

Experimental features are functional but have not been tested extensively enough to be recommended for production use.

## Unified diff

The Unified Diff feature, introduced in version 2.1.0, provides output similar to `difflib.unified_diff()` but with added awareness of out-of-order lines and parent-child relationships in the Hier Config model of configurations being compared.

This feature is particularly useful when comparing configurations from two network devices, such as redundant pairs, or when validating differences between running and intended configurations.

Currently, the algorithm does not account for duplicate child entries (e.g., multiple `endif` statements in an IOS-XR route-policy) or enforce command order in sections where it may be critical, such as Access Control Lists (ACLs). For accurate ordering in ACLs, sequence numbers should be used if command order is important.

```bash
>>> from hier_config import get_hconfig
>>> from hier_config.model import Platform
>>> from pprint import pprint
>>>
>>> running_config_text = open("./tests/fixtures/running_config.conf").read()
>>> generated_config_text = open("./tests/fixtures/generated_config.conf").read()
>>>
>>> running_config = get_hconfig(Platform.CISCO_IOS, running_config_text)
>>> generated_config = get_hconfig(Platform.CISCO_IOS, generated_config_text)
>>>
>>> pprint(list(running_config.unified_diff(generated_config)))
['vlan 3',
 '  - name switch_mgmt_10.0.4.0/24',
 '  + name switch_mgmt_10.0.3.0/24',
 'interface Vlan2',
 '  - shutdown',
 '  + mtu 9000',
 '  + ip access-group TEST in',
 '  + no shutdown',
 'interface Vlan3',
 '  - description switch_mgmt_10.0.4.0/24',
 '  - ip address 10.0.4.1 255.255.0.0',
 '  + description switch_mgmt_10.0.3.0/24',
 '  + ip address 10.0.3.1 255.255.0.0',
 '+ vlan 4',
 '  + name switch_mgmt_10.0.4.0/24',
 '+ interface Vlan4',
 '  + mtu 9000',
 '  + description switch_mgmt_10.0.4.0/24',
 '  + ip address 10.0.4.1 255.255.0.0',
 '  + ip access-group TEST in',
 '  + no shutdown']
>>>
```

## Future Config

FThe Future Config feature, introduced in version 2.2.0, attempts to predict the state of the running configuration after a change is applied.

This feature is useful in scenarios where you need to determine the anticipated configuration state following a change, such as:
- Verifying that a configuration change was successfully applied to a device
  - For example, checking if the post-change configuration matches the predicted future configuration
- Generating a future-state configuration that can be analyzed by tools like Batfish to assess the potential impact of a change
- Building rollback configurations: once the future configuration state is known, a rollback configuration can be generated by simply creating the remediation in reverse `(rollback = future.config_to_get_to(running))`.
  - When building rollbacks for a series of configuration changes, you can use the future configuration from each change as input for the subsequent change. For example, use the future configuration after Change 1 as the input for determining the future configuration after Change 2, and so on.
      ```shell
      post_change_1_config = running_config.future(change_1_config)
      change_1_rollback_config = post_change_1_config.config_to_get_to(running_config)
      post_change_2_config = post_change_1_config.future(change_2_config)
      change_2_rollback_config = post_change_2_config.config_to_get_to(post_change_1_config)
      ...
      ```

Currently, this algorithm does not account for:
- negate a numbered ACL when removing an item
- sectional exiting
- negate with
- idempotent command avoid
- idempotent_acl_check
- and likely others

```bash
>>> from hier_config import get_hconfig
>>> from hier_config.model import Platform
>>> from pprint import pprint
>>>
>>> running_config_text = open("./tests/fixtures/running_config.conf").read()
>>> remediation_config_text = open("./tests/fixtures/remediation_config_without_tags.conf").read()
>>>
>>> running_config = get_hconfig(Platform.CISCO_IOS, running_config_text)
>>> remediation_config = get_hconfig(Platform.CISCO_IOS, remediation_config_text)
>>>
>>> print("Running Config")
Running Config
>>> for line in running_config.all_children():
...     print(line.cisco_style_text())
...
hostname aggr-example.rtr
ip access-list extended TEST
  10 permit ip 10.0.0.0 0.0.0.7 any
vlan 2
  name switch_mgmt_10.0.2.0/24
vlan 3
  name switch_mgmt_10.0.4.0/24
interface Vlan2
  descripton switch_10.0.2.0/24
  ip address 10.0.2.1 255.255.255.0
  shutdown
interface Vlan3
  mtu 9000
  description switch_mgmt_10.0.4.0/24
  ip address 10.0.4.1 255.255.0.0
  ip access-group TEST in
  no shutdown
>>>
>>> print("Remediation Config")
Remediation Config
>>> for line in remediation_config.all_children():
...     print(line.cisco_style_text())
...
vlan 3
  name switch_mgmt_10.0.3.0/24
vlan 4
  name switch_mgmt_10.0.4.0/24
interface Vlan2
  mtu 9000
  ip access-group TEST in
  no shutdown
interface Vlan3
  description switch_mgmt_10.0.3.0/24
  ip address 10.0.3.1 255.255.0.0
interface Vlan4
  mtu 9000
  description switch_mgmt_10.0.4.0/24
  ip address 10.0.4.1 255.255.0.0
  ip access-group TEST in
  no shutdown
>>>
>>> print("Future Config")
Future Config
>>> for line in running_config.future(remediation_config).all_children():
...     print(line.cisco_style_text())
...
vlan 3
  name switch_mgmt_10.0.3.0/24
vlan 4
  name switch_mgmt_10.0.4.0/24
interface Vlan2
  mtu 9000
  ip access-group TEST in
  descripton switch_10.0.2.0/24
  ip address 10.0.2.1 255.255.255.0
interface Vlan3
  description switch_mgmt_10.0.3.0/24
  ip address 10.0.3.1 255.255.0.0
  mtu 9000
  ip access-group TEST in
  no shutdown
interface Vlan4
  mtu 9000
  description switch_mgmt_10.0.4.0/24
  ip address 10.0.4.1 255.255.0.0
  ip access-group TEST in
  no shutdown
hostname aggr-example.rtr
ip access-list extended TEST
  10 permit ip 10.0.0.0 0.0.0.7 any
vlan 2
  name switch_mgmt_10.0.2.0/24
>>>
```

## JunOS-style Syntax Remediation
Operating systems that use "set"-based syntax can now be remediated experimentally. Below is an example of a JunOS-style remediation.

```bash
$ cat ./tests/fixtures/running_config_flat_junos.conf
set system host-name aggr-example.rtr

set firewall family inet filter TEST term 1 from source-address 10.0.0.0/29
set firewall family inet filter TEST term 1 then accept

set vlans switch_mgmt_10.0.2.0/24 vlan-id 2
set vlans switch_mgmt_10.0.2.0/24 l3-interface irb.2

set vlans switch_mgmt_10.0.4.0/24 vlan-id 3
set vlans switch_mgmt_10.0.4.0/24 l3-interface irb.3

set interfaces irb unit 2 family inet address 10.0.2.1/24
set interfaces irb unit 2 family inet description "switch_10.0.2.0/24"
set interfaces irb unit 2 family inet disable

set interfaces irb unit 3 family inet address 10.0.4.1/16
set interfaces irb unit 3 family inet filter input TEST
set interfaces irb unit 3 family inet mtu 9000
set interfaces irb unit 3 family inet description "switch_mgmt_10.0.4.0/24"


$ python3
>>> from hier_config import WorkflowRemediation, get_hconfig
>>> from hier_config.model import Platform
>>>
>>> running_config_text = open("./tests/fixtures/running_config_flat_junos.conf").read()
>>> generated_config_text = open("./tests/fixtures/generated_config_flat_junos.conf").read()
# Create HConfig objects for the running and generated configurations using JunOS syntax
>>> running_config = get_hconfig(Platform.JUNIPER_JUNOS, running_config_text)
>>> generated_config = get_hconfig(Platform.JUNIPER_JUNOS, generated_config_text)
>>>
# Initialize WorkflowRemediation with the running and generated configurations
>>> workflow = WorkflowRemediation(running_config, generated_config)
>>>
# Generate and display the remediation configuration
>>> print("Remediation configuration:")
Remediation configuration:
>>> print(str(workflow.remediation_config))
delete vlans switch_mgmt_10.0.4.0/24 vlan-id 3
delete vlans switch_mgmt_10.0.4.0/24 l3-interface irb.3
delete interfaces irb unit 2 family inet disable
delete interfaces irb unit 3 family inet address 10.0.4.1/16
delete interfaces irb unit 3 family inet description "switch_mgmt_10.0.4.0/24"
set vlans switch_mgmt_10.0.3.0/24 vlan-id 3
set vlans switch_mgmt_10.0.3.0/24 l3-interface irb.3
set vlans switch_mgmt_10.0.4.0/24 vlan-id 4
set vlans switch_mgmt_10.0.4.0/24 l3-interface irb.4
set interfaces irb unit 2 family inet filter input TEST
set interfaces irb unit 2 family inet mtu 9000
set interfaces irb unit 3 family inet address 10.0.3.1/16
set interfaces irb unit 3 family inet description "switch_mgmt_10.0.3.0/24"
set interfaces irb unit 4 family inet address 10.0.4.1/16
set interfaces irb unit 4 family inet filter input TEST
set interfaces irb unit 4 family inet mtu 9000
set interfaces irb unit 4 family inet description "switch_mgmt_10.0.4.0/24"
>>>
```

Configurations loaded into Hier Config with Juniper-style syntax are converted to a flat, `set`-based format. Remediation steps are then generated using this `set` syntax.

```bash
$ cat ./tests/fixtures/running_config_junos.conf 
system {
    host-name aggr-example.rtr;
}

firewall {
    family inet {
        filter TEST {
            term 1 {
                from {
                    source-address 10.0.0.0/29;
                }
                then {
                    accept;
                }
            }
        }
    }
}

vlans {
    switch_mgmt_10.0.2.0/24 {
        vlan-id 2;
        l3-interface irb.2;
    }
    switch_mgmt_10.0.4.0/24 {
        vlan-id 3;
        l3-interface irb.3;
    }
}

interfaces {
    irb {
        unit 2 {
            family inet {
                address 10.0.2.1/24;
                description "switch_10.0.2.0/24";
                disable;
            }
        }
        unit 3 {
            family inet {
                address 10.0.4.1/16;
                filter {
                    input TEST;
                }
                mtu 9000;
                description "switch_mgmt_10.0.4.0/24";
            }
        }
    }
}

$ python3
>>> from hier_config import WorkflowRemediation, get_hconfig
>>> from hier_config.model import Platform
>>>
>>> running_config_text = open("./tests/fixtures/running_config_junos.conf").read()
>>> generated_config_text = open("./tests/fixtures/generated_config_junos.conf").read()
# Create HConfig objects for the running and generated configurations using JunOS syntax
>>> running_config = get_hconfig(Platform.JUNIPER_JUNOS, running_config_text)
>>> generated_config = get_hconfig(Platform.JUNIPER_JUNOS, generated_config_text)
>>>
# Initialize WorkflowRemediation with the running and generated configurations
>>> workflow = WorkflowRemediation(running_config, generated_config)
>>>
# Generate and display the remediation configuration
>>> print("Remediation configuration:")
Remediation configuration:
>>> print(str(workflow.remediation_config))
delete vlans switch_mgmt_10.0.4.0/24 vlan-id 3
delete vlans switch_mgmt_10.0.4.0/24 l3-interface irb.3
delete interfaces irb unit 2 family inet description "switch_10.0.2.0/24"
delete interfaces irb unit 2 family inet disable
delete interfaces irb unit 3 family inet address 10.0.4.1/16
delete interfaces irb unit 3 family inet description "switch_mgmt_10.0.4.0/24"
set vlans switch_mgmt_10.0.3.0/24 vlan-id 3
set vlans switch_mgmt_10.0.3.0/24 l3-interface irb.3
set vlans switch_mgmt_10.0.4.0/24 vlan-id 4
set vlans switch_mgmt_10.0.4.0/24 l3-interface irb.4
set interfaces irb unit 2 family inet filter input TEST
set interfaces irb unit 2 family inet mtu 9000
set interfaces irb unit 2 family inet description "switch_mgmt_10.0.2.0/24"
set interfaces irb unit 3 family inet address 10.0.3.1/16
set interfaces irb unit 3 family inet description "switch_mgmt_10.0.3.0/24"
set interfaces irb unit 4 family inet address 10.0.4.1/16
set interfaces irb unit 4 family inet filter input TEST
set interfaces irb unit 4 family inet mtu 9000
set interfaces irb unit 4 family inet description "switch_mgmt_10.0.4.0/24"
>>>
```